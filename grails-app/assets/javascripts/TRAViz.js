/*

Copyright (C) 2014, Stefan Jänicke.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

2. It is prohibited to remove, hide or modify any visual copyright notice
generated by this Software.

3. When using screenshots of any part of the visual output generated by
this Software for presentations or on websites the following link MUST
be clearly visible for the beholder: http://traviz.vizcovery.org

4. When using screenshots of any part of the visual output generated by
this Software in publications, the following reference MUST be inserted: 

S. Jänicke, A. Geßner, M. Büchler and G. Scheuermann (2014). Visualizations
for Text Re-use. In Proceedings of the 5th International Conference on
Information Visualization Theory and Applications, IVAPP 2014, pages 59–70.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(Fair Academic License (FAL), http://vizcovery.org/fal.html)

*/

/**
 * -------------------------------------------------------
 * CLASS TRAViz
 * -------------------------------------------------------
 * main component of the system
 * requires the id of a <div> and optional individual configurations in form of a json object <options>
 * holds the graph and implements its visualization
 */
function TRAViz(div,options){
	this.div = div;
	this.config = new TRAVizConfig(options);
	this.curveRadius = this.config.options.curveRadius;
	this.graph = new TRAVizGraph(this.config);
	this.startVertex = new TRAVizVertex(this.graph,'first','');
	this.graph.addVertex(this.startVertex);
	this.endVertex = new TRAVizVertex(this.graph,'last','');
	this.graph.addVertex(this.endVertex);
	this.graph.startVertex = this.startVertex;
	this.graph.endVertex = this.endVertex;
}

/**
 * triggers the alignment of the given <sources> that evolves the Text Variant Graph
 */
TRAViz.prototype.align = function(sources){
	this.editions = [];
	this.sentences = [];
	this.colorMap = [];
	var colors = this.config.getColors(sources.length);
	for( var i=0; i<sources.length; i++ ){
		this.editions.push(sources[i].edition);
		this.sentences.push(sources[i].text);
		this.colorMap[sources[i].edition] = colors[i];
	}
	this.mainBranch = this.editions[0];
	this.aligner = new TRAVizAligner(this.graph,this.config);
	this.sentencePaths = this.aligner.alignSentences(this.sentences);
	this.sentencePathHash = [];
	for( var i=0; i<this.editions.length; i++ ){
		this.sentencePathHash[this.editions[i]] = this.sentencePaths[i];
	}
	this.vertices = this.aligner.graph.vertices;
	
	//=========================================================================================
	/*
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var tl = "";
		var c = 0;
		var tokenNameHash = [];
		for( var j=0; j<v.sources.length; j++ ){
			var token = v.sources[j].token;
			var found = false;
			for( var k=0; k<tokenNameHash.length; k++ ){
				if( tokenNameHash[k].t == token ){
					tokenNameHash[k].c++;
					found = true;
					if( tokenNameHash[k].c > c ){
						tl = token;
						c = tokenNameHash[k].c;
					}
					break;
				}
			}
			if( !found ){
				tokenNameHash.push({
					t: token,
					c: 1
				});
				if( c == 0 ){
					tl = token;
					c = 1;
				}
			}
		}
		v.token = tl;
	}
	*/
	//======================================================================================
	
	this.originGraph = this.graph;
	this.originSentencePaths = [];
	for( var i=0; i<this.sentencePaths.length; i++ ){
		this.originSentencePaths.push([]);
		for( var j=0; j<this.sentencePaths[i].length; j++ ){
			this.originSentencePaths.push(this.sentencePaths[i][j]);
		}
	}
}

/**
 * updates all sentence paths after merge or split operations
 */
TRAViz.prototype.reset = function(v){
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=p.length; j>0; j-- ){
			if( p[j-1].dummy ){
				p.splice(j-1,1);
			}
		}
	}
	for( var i=0; i<this.originGraph.vertices.length; i++ ){
		var v = this.originGraph.vertices[i];
		v.predecessors = [];
		v.successors = [];
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=0; j<p.length-1; j++ ){
			this.originGraph.getVertex(p[j].index).addSuccessor(p[j+1].index);
			this.originGraph.getVertex(p[j+1].index).addPredecessor(p[j].index);
		}
	}
	this.graph = this.originGraph.clone();
	this.aligner.graph = this.graph;
	this.vertices = this.graph.vertices;
	this.startVertex = this.graph.getVertex("first");
	this.endVertex = this.graph.getVertex("last");
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=p.length; j>0; j-- ){
			p[j-1] = this.graph.getVertex(p[j-1].index);
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		v.layer = undefined;
		v.originLayer = undefined;
		var tl = "";
		var c = 0;
		var tokenNameHash = [];
		for( var j=0; j<v.sources.length; j++ ){
			var token = v.sources[j].token;
			var found = false;
			for( var k=0; k<tokenNameHash.length; k++ ){
				if( tokenNameHash[k].t == token ){
					tokenNameHash[k].c++;
					found = true;
					if( tokenNameHash[k].c > c ){
						tl = token;
						c = tokenNameHash[k].c;
					}
					break;
				}
			}
			if( !found ){
				tokenNameHash.push({
					t: token,
					c: 1
				});
				if( c == 0 ){
					tl = token;
					c = 1;
				}
			}
		}
		v.token = tl;
	}
}

/**
 * Overwrites the colormap
 */
TRAViz.prototype.setColorMap = function(colorMap){
	this.colorMap = colorMap;
}

/**
 * Initializes a 'visual' connection for each adjacent vertex pair
 * dependent on the layers of the corresponding vertices, a different connection type is assigned
 */
TRAViz.prototype.prepareConnections = function(){
	this.connections = [];
	var horizontalSlots = [];
	for( var i=0; i<this.layers.length; i++ ){
		var hs = {
			height: 0,
			paths: [],
			index: this.layers[i].index
		};
		horizontalSlots.push(hs);
	}
	var putHorizontalSlot = function(layer,hc){
		for( var i=0; i<horizontalSlots.length; i++ ){
			if( horizontalSlots[i].index == layer ){
				horizontalSlots[i].paths.push(hc);
				break;
			}
		}
	}
	var sal = this;
	var setSlotHeights = function(){
		var x_min = 1000000, x_max = 0;
		for( var i=0; i<sal.layout.length; i++ ){
			var v = sal.layout[i];
			if( v.x1 < x_min ){
				x_min = v.x1;
			}
			if( v.x2 > x_max ){
				x_max = v.x2;
			}
		}
		var equalGroups = function(g1,g2){
			if( g1.length != g2.length ){
				return false;
			}
			for( var i=0; i<g1.length; i++ ){
				if( g1[i] != g2[i] ){
					return false;
				}
			}
			return true;
		}
		for( var i=0; i<horizontalSlots.length; i++ ){
			var s = horizontalSlots[i];
			var max = 0;
			var groups = [];
			for( var j=x_min; j<x_max; j++ ){
				var group = [];
				for( var k=0; k<s.paths.length; k++ ){
					if( s.paths[k].v1.x2 < j && s.paths[k].v2.x1 > j ){
						group.push(s.paths[k]);
					}
				}
				if( group.length > 0 && ( groups.length == 0 || !equalGroups(groups[groups.length-1],group) ) ){
					groups.push(group);
				}
			}
			var max = 0;
			for( var j=0; j<groups.length; j++ ){
				if( groups[j].length > max ){
					max = groups[j].length;
				}
			}
			s.height = max*3 + 2*sal.curveRadius;
			s.groups = groups;
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var p = v.successors;
		for( var j=0; j<p.length; j++ ){
			var v1 = v;
			var v2 = this.graph.getVertex(p[j]);
			if( !this.config.options.startAndEnd && ( v1 == this.startVertex || v2 == this.endVertex ) ){
				continue;
			}
			if( v.token == '' && v2.token == '' && !v2.linebreak && v2 != this.endVertex ){
				continue;
			}
			if( v1.layer == v2.layer ){
				var overlaps = false;
				for( var k=0; k<this.vertices.length; k++ ){
					if( this.vertices[k] == v1 || this.vertices[k] == v2 ){
						continue;
					}
					if( this.vertices[k].layer == v1.layer && v1.x1 < this.vertices[k].x1 && this.vertices[k].x1 < v2.x1 ){
						overlaps = true;
						break;
					}
				}
				if( overlaps ){
					var con = new TRAVizConnection(v1,v2,0);
					var vc1 = new TRAVizVerticalConnection(v1,v2,'source');
					var hc = new TRAVizHorizontalConnection(v1,v2,0);
					var vc2 = new TRAVizVerticalConnection(v1,v2,'sink');
					this.connections.push(con);
					con.addLink(vc1);
					con.addLink(hc);
					con.addLink(vc2);
					putHorizontalSlot(v1.layer,hc);
				}
				else {
					this.connections.push(new TRAVizConnection(v1,v2,-1));
				}
			}
			else {
				var con = new TRAVizConnection(v1,v2,3);
				this.connections.push(con);
				var vc1 = new TRAVizVerticalConnection(v1,v2,'source');
				var hc = new TRAVizHorizontalConnection(v1,v2,3);
				var vc2 = new TRAVizVerticalConnection(v1,v2,'sink');
				if( Math.abs(v1.layer) > Math.abs(v2.layer) ){
					if( v1.layer < 0 ){
						putHorizontalSlot(v1.layer+1,hc);
					} 
					else {
						putHorizontalSlot(v1.layer,hc);
					}
				}
				else {
					if( v2.layer < 0 ){
						putHorizontalSlot(v2.layer+1,hc);
					} 
					else {
						putHorizontalSlot(v2.layer,hc);
					}
				}
				con.addLink(vc1);
				con.addLink(hc);
				con.addLink(vc2);
			}
		}
	}
	setSlotHeights();
	this.horizontalSlots = horizontalSlots;
}

/**
 * Adds the given edge <e={h,t}> to its corresponding group
 */
TRAViz.prototype.addEdgeToGroup = function(h,t,e,ids){
	var found = false;
	for( var i=0; i<this.edgeGroups.length; i++ ){
		var g = this.edgeGroups[i];
		if( g.h == h && g.t == t ){
			g.edges.push(e);
			g.ids = g.ids.concat(ids);
			found = true;
			break;
		}
	}
	if( !found ){
		this.edgeGroups.push({
			h: h,
			t: t,
			edges: [e],
			ids: ids
		});
	}
}

/**
 * Adds the given edge <e={h,t}> to its corresponding group
 */
TRAViz.prototype.computeEdgeLabels = function(){
	for( var i=0; i<this.edgeGroups.length; i++ ){
		var g = this.edgeGroups[i];
		var tiptext = "";
		for( var j=0; j<g.ids.length; j++ ){
			tiptext += "<div style='text-align:center;color:"+this.colorMap[this.editions[g.ids[j]]]+";'>"+this.editions[g.ids[j]]+"</div>";
		}
		for( var j=0; j<g.edges.length; j++ ){
			$(g.edges[j].node).qtip({
				content: {	
					text: tiptext
				},
				style: {
					tip: true,
					border: { width: 0, radius: 4 },
					width : { min: 100, max: 500 }
				},
				position: {
					target: 'mouse',
					corner: {
						tooltip: "bottomMiddle",
						target: "topMiddle"
					},
					adjust : { x: -6 }
				},
				show: {
					when: 'mouseenter', 
					solo: true
				},
				hide: {
					when: { event: 'mouseleave' }
				}
			});
		}
	}
};

/**
 * Draws joined connections
 */
TRAViz.prototype.generalConnections = function(){		
	for( var i=0; i<this.connections.length; i++ ){
		var path = this.generatePath(this.connections[i],0,0);
		var pvis = this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 3, "stroke-linecap": "round", "opacity": "0.8"});
		this.basicConnections.push(pvis);
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( v == this.startVertex || v == this.endVertex || v.token == '' ){
			continue;
		}
		if( this.config.options.vertexBackground ){
			v.rect.toFront();
		}
		if( v.count > this.config.options.collapseLabels ){
			v.textNode.toFront();
		}
	}
}

/**
 * Positions all required vertical connections 
 */
TRAViz.prototype.adjustVerticalConnections = function(){
	var verticals = [];
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		var x1 = c.v1.x2;
		var x2 = c.v2.x1;
		var xc = (x1+x2)/2;
		var y1 = (c.v1.y1+c.v1.y2)/2;
		var y2 = (c.v2.y1+c.v2.y2)/2;
		if( c.type == 1 ){
			var vy1, vy2;
			if( y1 > y2 ){
				vy1 = y1 - this.curveRadius;
				vy2 = y2 + this.curveRadius;
			}
			else {
				vy1 = y1 + this.curveRadius;
				vy2 = y2 - this.curveRadius;
			}
			var vc = c.links[0];
			vc.position(xc,vy1,vy2);
			verticals.push(vc);
		}
		else if( c.type == 0 || c.type == 3 ){
			var h = c.links[1];
			var v1x = x1 + this.curveRadius;
			var v1y1, v1y2;
			if( c.v1.layer >= c.v2.layer ){
				v1y1 = y1 - this.curveRadius;
				v1y2 = h.y1 + this.curveRadius;
			}
			else {
				v1y1 = y1 + this.curveRadius;
				v1y2 = h.y1 - this.curveRadius;
			}
			var vc1 = c.links[0];
			vc1.position(v1x,v1y1,v1y2);
			verticals.push(vc1);
			var v2x = x2 - this.curveRadius;
			var v2y1, v2y2;
			if( c.v1.layer <= c.v2.layer ){
				v2y1 = h.y1 + this.curveRadius;
				v2y2 = y2 - this.curveRadius;
			}
			else {
				v2y1 = h.y1 - this.curveRadius;
				v2y2 = y2 + this.curveRadius;
			}
			var vc2 = c.links[c.links.length-1];
			vc2.position(v2x,v2y1,v2y2);
			verticals.push(vc2);
		}
	}
	this.verticals = verticals;
	var sortVerticals = function(v1,v2){
		if( v1.x1 < v2.x1 ){
			return -1;
		}
		if( v1.x1 == v2.x1 && v1.yMax() > v2.yMax() ){
			return -1;
		}
		return 1;
	}
	verticals.sort(sortVerticals);
	var groups = [];
	for( var j=0; j<verticals.length; j++ ){
		var sourceFound = false;
		var sinkFound = false;
		for( var k=0; k<groups.length; k++ ){
			if( ( verticals[j].type == 'source' || verticals[j].type == 1 ) && groups[k].source == verticals[j].v1 ){
				sourceFound = true;
				groups[k].paths.push(verticals[j]);
				if( verticals[j].yMin() < groups[k].y1 ){
					groups[k].y1 = verticals[j].yMin();
				}
				if( verticals[j].yMax() > groups[k].y2 ){
					groups[k].y2 = verticals[j].yMax();
				}
			}
			if( ( verticals[j].type == 'sink' || verticals[j].type == 1 ) && groups[k].sink == verticals[j].v2 ){
				sinkFound = true;
				groups[k].paths.push(verticals[j]);
				if( verticals[j].yMin() < groups[k].y1 ){
					groups[k].y1 = verticals[j].yMin();
				}
				if( verticals[j].yMax() > groups[k].y2 ){
					groups[k].y2 = verticals[j].yMax();
				}
			}
		}
		if( !sourceFound && verticals[j].type != 'sink' ){
			groups.push({
				vertex: verticals[j].v1,
				source: verticals[j].v1,
				paths: [verticals[j]],
				y1: verticals[j].yMin(),
				y2: verticals[j].yMax(),
				x: verticals[j].v1.x2 + this.curveRadius
			});
		}
		if( !sinkFound && verticals[j].type != 'source' ){
			groups.push({
				vertex: verticals[j].v2,
				sink: verticals[j].v2,
				paths: [verticals[j]],
				y1: verticals[j].yMin(),
				y2: verticals[j].yMax(),
				x: verticals[j].v2.x1 - this.curveRadius
			});
		}
	}
	var sortGroupsBySize = function(g1,g2){
		if( g1.paths.length > g2.paths.length ){
			return 1;
		}
		if( g1.paths.length == g2.paths.length && Math.abs(g1.vertex.originLayer) < Math.abs(g2.vertex.originLayer) ){
			return 1;
		}
		return -1;
	}
	groups.sort(sortGroupsBySize);
	var groupsToPlace = [];
	for( var j=groups.length; j>0; j-- ){
		var g1 = groups[j-1];
		var ng1 = [];
		for( var k=0; k<g1.paths.length; k++ ){
			if( !g1.paths[k].placed ){
				ng1.push(g1.paths[k]);
			}
		}
		if( ng1.length < g1.paths.length ){
			if( ng1.length == 0 ){
				groups.pop();
				continue;
			}
			g1.paths = ng1;
			groups.sort(sortGroupsBySize);
			j = groups.length+1;
			continue;
		}
		for( var k=0; k<g1.paths.length; k++ ){
			g1.paths[k].placed = true;
		}
		groupsToPlace.push(g1);
		groups.pop();
	}
	groups = groupsToPlace;
	var sortGroupsByX = function(g1,g2){
		if( g1.x < g2.x ){
			return 1;
		}
		if( g1.x == g2.x ){
			if( g1.paths.length > g2.paths.length && g1.source ){
				return 1;
			}
		}
		return -1;
	}
	groups.sort(sortGroupsByX);
	var placedGroups = [];
	for( var j=groups.length; j>0; j-- ){
		var g1 = groups[j-1];
		if( typeof g1.source != 'undefined' ){
			var ox = g1.x;
			var nx = g1.paths[0].v1.x2 + this.curveRadius;
			if( ox != nx ){
				g1.x = nx;
				groups.sort(sortGroupsByX);
				j = groups.length+1;
				continue;
			}
		}
		if( typeof g1.sink != 'undefined' ){
			var ox = g1.x;
			var nx = g1.paths[0].v2.x1 - this.curveRadius;
			if( ox != nx ){
				g1.x = nx;
				groups.sort(sortGroupsByX);
				j = groups.length+1;
				continue;
			}
		}
		do {
			var overlap = false;
			for( var k=0; k<placedGroups.length; k++ ){
				var g2 = placedGroups[k];
				if( Math.abs(g1.x-g2.x) < this.config.options.edgeGap && !( g1.y1 > g2.y2 || g2.y1 > g1.y2 ) ){
					overlap = true;
					g1.x += this.config.options.edgeGap - Math.abs(g1.x-g2.x);
				}
			}
		}
		while(overlap);
		for( var k=0; k<g1.paths.length; k++ ){
			var p = g1.paths[k];
			p.x1 = g1.x;
			p.x2 = g1.x;
			p.gc = g1.paths.length;
			var v = p.v2;
			if( v.x1 - g1.x < this.curveRadius ){
				var s = this.curveRadius - ( v.x1 - g1.x );
				v.x1 += s;
				v.x2 += s;
				var pairs = [];
				for( var m=0; m<v.successors.length; m++ ){
					if( v.level == this.graph.getVertex(v.successors[m]).level ){
						pairs.push({
							head: v,
							tail: this.graph.getVertex(v.successors[m])
						});
					}
				}
				while( pairs.length > 0 ){
					var pairsNew = [];
					for( var m=0; m<pairs.length; m++ ){
						var v1 = pairs[m].head;
						var v2 = pairs[m].tail;
						if( v2.x1-v1.x2 < 4*this.curveRadius ){
							var sh = 4*this.curveRadius - ( v2.x1-v1.x2 ); 
							v2.x1 += sh;
							v2.x2 += sh;
							for( var n=0; n<v2.successors.length; n++ ){
								pairsNew.push({
									head: v2,
									tail: this.graph.getVertex(v2.successors[n])
								});
							}
						}
					}
					pairs = pairsNew;
				}
			}
		}
		placedGroups.push(g1);
		groups.pop();
	}
}

/**
 * Removes a vertical connection
 */
TRAViz.prototype.removeVertical = function(v){
	for( var i=0; i<this.verticals.length; i++ ){
		if( this.verticals[i] == v ){
			this.verticals.splice(i,1);
			return;
		}
	}	
}

/**
 * Removes overlaps between vertical connections and vertices
 */
TRAViz.prototype.removeOverlaps = function(){
	var sortVerticals = function(v1,v2){
		if( v1.x1 > v2.x1 ){
			return 1;
		}
		if( v1.x1 == v2.x1 ){
			return 0;
		}
		return -1;
	}
	for( var i=0; i<this.verticals.length; i++ ){
		for( var j=0; j<this.vertices.length; j++ ){
			if( this.vertices[j].token == '' ){
				continue;
			}
			var x11 = this.verticals[i].x1 - this.curveRadius, x12 = this.verticals[i].x2 + this.curveRadius, y11 = this.verticals[i].yMin() - this.curveRadius, y12 = this.verticals[i].yMax() + this.curveRadius;
			var x21 = this.vertices[j].x1, x22 = this.vertices[j].x2, y21 = this.vertices[j].y1, y22 = this.vertices[j].y2;
			if( this.overlap(x11,x12,x21,x22,y11,y12,y21,y22) ){
				var v1 = this.vertices[j];
				var ml = Math.abs(this.vertices[j].x2 - x11);
				var mr = Math.abs(v1.x1 - x12);
				var moved = false;
				var moveLeft = true;
				for( var k=0; k<this.vertices.length; k++ ){
					var v0 = this.vertices[k];
					if( v1 == v0 ){
						continue;
					}
					if( v0 == this.startVertex && !this.config.options.startAndEnd ){
						continue;
					}
					var con = this.getConnection(v0,v1);
					if( !con ){
						moveLeft = false;
					}
					else if( con.type == 1 && con.links[0].x1 + this.curveRadius >= v1.x1 - ml ){
						moveLeft = false;
					}
					else if( con.type == -1 && con.v2.x1 - con.v1.x2 - 3*this.curveRadius < ml ){
						moveLeft = false;
					}
					else if( con.type != -1 && con.type != 1 ){
						moveLeft = false;
					}
				}
				if( moveLeft ){
					moved = true;
					v1.x1 -= ml;
					v1.x2 -= ml;
				}
				if( !moved ){
					var moveRight = true;
					for( var k=0; k<this.vertices.length; k++ ){
						var v2 = this.vertices[k];
						if( v1 == v2 ){
							continue;
						}
						var con = this.getConnection(v1,v2);
						if( v2 == this.endVertex && !this.config.options.startAndEnd ){
							continue;
						}
						if( !con ){
							moveRight = false;
						}
						else if( con.type == 1 && con.links[0].x1 - this.curveRadius < v1.x2 + mr ){
							moveRight = false;
						}
						else if( con.type == -1 && con.v2.x1 - con.v1.x2 - 3*this.curveRadius < mr ){
							moveRight = false;
						}
						else if( con.type != -1 && con.type != 1 ){
							moveRight = false;
						}
					}
					if( moveRight ){
						moved = true;
						v1.x1 += mr;
						v1.x2 += mr;
					}
				}
				/*
				if( !moved ){
					var verticesToMove = [];
					var hash = [];
					var traverse = [v1];
					var layer = this.getLayer(v1.layer);
					layer.vertices.sort(sortVerticals);
					var locked = true;
					for( var m=0; m<layer.vertices.length; m++ ){
						if( !locked ){
							traverse.push(layer.vertices[m]);
						}
						if( layer.vertices[m] == v1 ){
							locked = false;
						}
					}
					while( traverse.length > 0 ){
						var newTraverse = [];
						for( var k=0; k<traverse.length; k++ ){
							if( !hash[traverse[k].index] ){
								hash[traverse[k].index] = true;
								traverse[k].x1 += mr;
								traverse[k].x2 += mr;
								for( var l=0; l<traverse[k].successors.length; l++ ){
									var suc = this.graph.getVertex(traverse[k].successors[l]);
									newTraverse.push(suc);
									var layer = this.getLayer(suc.layer);
									layer.vertices.sort(sortVerticals);
									var locked = true;
									for( var m=0; m<layer.vertices.length; m++ ){
										if( !locked ){
											newTraverse.push(layer.vertices[m]);
										}
										if( layer.vertices[m] == suc ){
											locked = false;
										}
									}
								}					
							}
						}
						traverse = newTraverse;
					}
					this.adjustVerticalConnections();
					this.verticals.sort(sortVerticals);
					i = 0;
				}*/
			}
		}
	}
	//this.setConnections();
}

/**
 * Transforms edges of type 3 into an edge of type 1, if possible
 */
TRAViz.prototype.transformEdgeTypes = function(){
	var horizontalSnippets = [];
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		if( c.type == 1 ){
			var v = c.links[0];
			var y1 = (c.v1.y1+c.v1.y2)/2;
			var y2 = (c.v2.y1+c.v2.y2)/2;
			horizontalSnippets.push({
				x1: c.v1.x2,
				x2: v.x1,
				y1: y1,
				y2: y1,
				v1: c.v1,
				v2: c.v2				
			});
			horizontalSnippets.push({
				x1: v.x1,
				x2: c.v2.x1,
				y1: y2,
				y2: y2,
				v1: c.v1,
				v2: c.v2				
			});
		}
	}
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		if( c.type == 0 || c.type == 3 ){
			var v1 = c.links[0];
			var h = c.links[1];
			var v2 = c.links[2];
			h.x1 = v1.x1 + this.curveRadius;
			h.x2 = v2.x1 - this.curveRadius;				
		}
	}
	var sortConnections = function(c1,c2){
		if( c1.v1.x2 > c2.v1.x2 ){
			return 1;
		}
		return -1;
	}
	this.connections.sort(sortConnections);
	for( var i=0; i<this.connections.length; i++ ){
		var c = this.connections[i];
		if( c.type == 3 ){
			var h = c.links[1];
			var y1 = (c.v1.y1+c.v1.y2)/2;
			var y2 = (c.v2.y1+c.v2.y2)/2;
			var x11 = h.x1 - this.curveRadius, x12 = h.x2 + this.curveRadius, y111 = c.v1.y1, y112 = c.v1.y2, y121 = c.v2.y1, y122 = c.v2.y2;
			var olV1 = false;
			var olV2 = false;
			for( var j=0; j<this.vertices.length; j++ ){
				var v = this.vertices[j];
				var x21 = v.x1, x22 = v.x2, y21 = v.y1, y22 = v.y2;
				if( this.overlap(x11,x12,x21,x22,y111,y112,y21,y22) ){
					olV1 = true;
					break;
				}				
				if( this.overlap(c.v2.x1-2*this.curveRadius,c.v2.x1,x21,x22,Math.min(y1,y2),Math.max(y1,y2),y21,y22) ){
//					olV1 = true;
//					break;
				}				
			}
			for( var j=0; j<horizontalSnippets.length; j++ ){
				var h = horizontalSnippets[j];
				if( c.v1 == h.v1 || c.v2 == h.v2 ){
					continue;
				}
				if( this.overlap(x11,x12,h.x1,h.x2,y111,y112,h.y1,h.y2) ){
					olV1 = true;
					break;
				}
			}
			for( var j=0; j<this.verticals.length; j++ ){
				var vert = this.verticals[j];
				if( c.v2 == vert.v2 ){
					continue;
				}
				if( this.overlap(c.links[2].x1,c.links[2].x1,vert.x1-this.config.options.edgeGap,vert.x2+this.config.options.edgeGap,Math.min(y1,y2),Math.max(y1,y2),Math.min(vert.y1,vert.y2),Math.max(vert.y1,vert.y2)) ){
					olV1 = true;
					break;
				}
			}
			for( var j=0; j<this.vertices.length; j++ ){
				var v = this.vertices[j];
				var x21 = v.x1, x22 = v.x2, y21 = v.y1, y22 = v.y2;
				if( this.overlap(x11,x12,x21,x22,y121,y122,y21,y22) ){
					olV2 = true;
					break;
				}
				if( this.overlap(c.v1.x2,c.v1.x2+2*this.curveRadius,x21,x22,Math.min(y1,y2),Math.max(y1,y2),y21,y22) ){
//					olV2 = true;
//					break;
				}				
			}
			for( var j=0; j<horizontalSnippets.length; j++ ){
				var h = horizontalSnippets[j];
				if( c.v1 == h.v1 || c.v2 == h.v2 ){
					continue;
				}
				if( this.overlap(x11,x12,h.x1,h.x2,y121,y122,h.y1,h.y2) ){
					olV2 = true;
					break;
				}
			}
			for( var j=0; j<this.verticals.length; j++ ){
				var vert = this.verticals[j];
				if( c.v1 == vert.v1 ){
					continue;
				}
				if( this.overlap(c.links[0].x1,c.links[0].x1,vert.x1-this.config.options.edgeGap,vert.x2+this.config.options.edgeGap,Math.min(y1,y2),Math.max(y1,y2),Math.min(vert.y1,vert.y2),Math.max(vert.y1,vert.y2)) ){
					olV2 = true;
					break;
				}
			}
			var draw1 = false, draw2 = false;
			if( olV1 && !olV2 ){
				draw1 = true;
			}
			else if( !olV1 && olV2 ){
				draw2 = true;
			}
			else if( !olV1 && !olV2 && c.links[0].gc > c.links[2].gc ){
				draw1 = true;
			}
			else if( !olV1 && !olV2 && c.links[0].gc < c.links[2].gc ){
				draw2 = true;
			}
			else if( !olV1 && !olV2 && Math.abs(c.v1.originLayer) < Math.abs(c.v2.originLayer) ){
				draw1 = true;
			}
			else if( !olV1 && !olV2 && Math.abs(c.v1.originLayer) >= Math.abs(c.v2.originLayer) ){
				draw2 = true;
			}
			if( draw1 ){
				c.type = 1;
				this.removeVertical(c.links[2]);
				var vc = c.links[0];
				vc.type = "source";
				var medl = (vc.v1.layer + vc.v2.layer)/2;
				if( vc.v1.layer < medl ){
					vc.y1 = y1 + this.curveRadius;
					vc.y2 = y2 - this.curveRadius;
				}
				else {
					vc.y1 = y1 - this.curveRadius;
					vc.y2 = y2 + this.curveRadius;
				}
				c.links = [vc];
				horizontalSnippets.push({
					x1: x11 - this.curveRadius,
					x2: x12 + this.curveRadius,
					y1: y121 - this.curveRadius,
					y2: y122 + this.curveRadius,
					v1: c.v1,
					v2: c.v2				
				});
			}
			if( draw2 ){
				c.type = 1;
				this.removeVertical(c.links[0]);
				var vc = c.links[2];
				vc.type = "sink";
				var medl = (vc.v1.layer + vc.v2.layer)/2;
				if( vc.v1.layer < medl ){
					vc.y1 = y1 + this.curveRadius;
					vc.y2 = y2 - this.curveRadius;
				}
				else {
					vc.y1 = y1 - this.curveRadius;
					vc.y2 = y2 + this.curveRadius;
				}
				c.links = [vc];
				horizontalSnippets.push({
					x1: x11 - this.curveRadius,
					x2: x12 + this.curveRadius,
					y1: y112 - this.curveRadius,
					y2: y112 + this.curveRadius,
					v1: c.v1,
					v2: c.v2				
				});
			}
		}
	}
}

/**
 * Positions all required horizontal connections 
 */
TRAViz.prototype.adjustHorizontalConnections = function(){
	var orderPaths = function(p1,p2){
		if( p1.type == 0 && p2.type == 0 ){
			if( p1.x2-p1.x1 < p2.x2-p2.x1 ){
				return -1;
			}
			return 1;
		}
		else if( p1.type == 0 ){
			return -1;
		}
		else if( p2.type == 0 ){
			return 1;
		}
		else {
			if( p1.x2 == p2.x2 ){
				if( p1.x1 < p2.x1 ){
					return -1;
				}
				return 1;
			}
			else if( p1.x2 < p2.x2 ){
				return -1;
			}
			return 1;
		}
	}
	for( var i=0; i<this.horizontalSlots.length; i++ ){
		var horizontals = [];
		var hs = this.horizontalSlots[i];
		var paths = hs.paths;
		for( var j=0; j<paths.length; j++ ){
			var hc = paths[j];
			var x1 = hc.v1.x2;
			var x2 = hc.v2.x1;
			var y = hs.yMax - 2;
			hc.position(x1+2*this.curveRadius,x2-2*this.curveRadius,y);
		}
		paths.sort(orderPaths);
		var groups = [];
		for( var j=0; j<paths.length; j++ ){
			var sourceFound = false;
			var sinkFound = false;
			for( var k=0; k<groups.length; k++ ){
				if( groups[k].source == paths[j].v1 ){
					sourceFound = true;
					groups[k].paths.push(paths[j]);
					if( paths[j].x1 < groups[k].x1 ){
						groups[k].x1 = paths[j].x1;
					}
					if( paths[j].x2 > groups[k].x2 ){
						groups[k].x2 = paths[j].x2;
					}
				}
				if( groups[k].sink == paths[j].v2 ){
					sinkFound = true;
					groups[k].paths.push(paths[j]);
					if( paths[j].x1 < groups[k].x1 ){
						groups[k].x1 = paths[j].x1;
					}
					if( paths[j].x2 > groups[k].x2 ){
						groups[k].x2 = paths[j].x2;
					}
				}
			}
			if( !sourceFound ){
				groups.push({
					source: paths[j].v1,
					paths: [paths[j]],
					x1: paths[j].x1,
					x2: paths[j].x2,
					y: paths[j].y1
				});
			}
			if( !sinkFound ){
				groups.push({
					sink: paths[j].v2,
					paths: [paths[j]],
					x1: paths[j].x1,
					x2: paths[j].x2,
					y: paths[j].y1
				});
			}
		}
		var sortGroups = function(g1,g2){
			if( g1.paths.length > g2.paths.length ){
				return 1;
			}
			return -1;
		}
		groups.sort(sortGroups);
		var placedGroups = [];
		for( var j=groups.length; j>0; j-- ){
			var g1 = groups[j-1];
			var ng1 = [];
			for( var k=0; k<g1.paths.length; k++ ){
				if( !g1.paths[k].placed ){
					ng1.push(g1.paths[k]);
				}
			}
			if( ng1.length < g1.paths.length ){
				g1.paths = ng1;
				groups.sort(sortGroups);
				j = groups.length+1;
				continue;
			}
			do {
				var overlap = false;
				for( var k=0; k<placedGroups.length; k++ ){
					var g2 = placedGroups[k];
					if( g1.y == g2.y && !( g1.x1 - this.curveRadius > g2.x2 || g2.x1 - this.curveRadius > g1.x2 ) ){
						overlap = true;
						g1.y -= this.config.options.edgeGap;
					}
				}
			}
			while(overlap);
			for( var k=0; k<g1.paths.length; k++ ){
				g1.paths[k].placed = true;
				g1.paths[k].y1 = g1.y;
				g1.paths[k].y2 = g1.y;
			}
			placedGroups.push(g1);
			groups.pop();
		}
	}
}

/**
 * When showing joined connections, this function can be called to highlight the path of edition <id>
 */
TRAViz.prototype.highlightEdition = function(id){
	var p = this.sentencePathHash[id];
	var path = "";
	for( var j=1; j<p.length; j++ ){
		path += this.generatePath(this.getConnection(p[j-1],p[j]),0,0);
	}
	var pvis = this.paper.path(path).attr({stroke: this.colorMap[id], "stroke-width": 4, "stroke-linecap": "round", "opacity": "1.0"});
	return pvis;
}

/**
 * Displays a line numbering when line breaks are used
 */
TRAViz.prototype.insertLineNumbering = function(width,gap){
	var line = 1;
	var x1 = this.curveRadius;
	var x2 = width - this.curveRadius;
	var y = this.layers[0].yLevel - this.layers[0].height/2 + 0.5 - Math.floor(gap/2) - 26;
	var path = "M "+x1+" "+y+" L "+x2+" "+y;
	this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 1, "stroke-linecap": "round", "opacity": "1.0"});
	this.paper.text(x1+7, y+14, this.config.options.lineNumberingText+" "+line).attr({font: "14px "+this.config.options.font,fill:this.config.options.baseColor,"text-anchor":"start","cursor":"default"});
	line++;
	for( var i=0; i<this.layers.length-1; i++ ){
		if( this.layers[i].level != this.layers[i+1].level ){
			var y = this.layers[i].yLevel + this.layers[i].height/2 + 0.5 + Math.floor(gap/2);
			var path = "M "+x1+" "+y+" L "+x2+" "+y;
			this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 1, "stroke-linecap": "round", "opacity": "1.0"});
			this.paper.text(x1+7, y+14, this.config.options.lineNumberingText+" "+line).attr({font: "14px "+this.config.options.font,fill:this.config.options.baseColor,"text-anchor":"start","cursor":"default"});
			line++;
		}
	}
	var y = this.layers[this.layers.length-1].yLevel + this.layers[this.layers.length-1].height/2 + 0.5 + Math.floor(gap/2);
	var path = "M "+x1+" "+y+" L "+x2+" "+y;
	this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 1, "stroke-linecap": "round", "opacity": "1.0"});
}

/**
 * Computes the path of the given <connection> with the given vertical shifts <s1> at the source vertex and <s2> at the sink vertex
 */
TRAViz.prototype.generatePath = function(connection,s1,s2){
	var bezier = function(x1,y1,xb,yb,x2,y2){
		return "C "+x1+" "+y1+" "+xb+" "+yb+" "+x2+" "+y2+" ";
	}
	var line = function(x1,y1,x2,y2){
		return "L "+x1+" "+y1+" "+x2+" "+y2+" ";
	}
	var c = connection;
	var x1 = c.v1.x2;
	var x2 = c.v2.x1;
	var y1 = (c.v1.y1+c.v1.y2)/2 + s1;
	var y2 = (c.v2.y1+c.v2.y2)/2 + s2;
	var path = "M "+x1+" "+y1+" ";
	if( c.type == -1 ){
		var xm = (x2+x1)/2;
		var ym = (y2+y1)/2;
		path += bezier(x1,y1,xm,y1,xm,ym);
		path += bezier(xm,ym,xm,y2,x2,y2);
	}
	else if( c.type == 0 || c.type == 3 ){
		var v1 = c.links[0];
		var h = c.links[1];
		var v2 = c.links[2];
		var v1x1 = v1.x1, v1x2 = v1.x2, v1y1 = v1.y1 + s1, v1y2 = v1.y2;
		var hx1 = h.x1, hx2 = h.x2, hy1 = h.y1, hy2 = h.y2;
		var v2x1 = v2.x1, v2x2 = v2.x2, v2y1 = v2.y1, v2y2 = v2.y2 + s2;
		var cr1 = this.curveRadius, cr2 = this.curveRadius;
		if( Math.abs(hy1-y1) < 2*this.curveRadius ){
			cr1 = Math.abs(hy1-y1)/2;
			var y = (hy1+y1)/2;
			v1y1 = y;
			v1y2 = y;
		}
		if( Math.abs(hy1-y2) < 2*this.curveRadius ){
			cr2 = Math.abs(hy1-y2)/2;
			var y = (hy1+y2)/2;
			v2y1 = y;
			v2y2 = y;
		}
		if( this.config.options.rtl ){
			cr1 *= -1;
			cr2 *= -1;
		}
		path += line(x1,y1,v1x1-cr1,y1);
		path += bezier(v1x1-cr1,y1,v1x1,y1,v1x1,v1y1);
		path += line(v1x1,v1y1,v1x2,v1y2);
		path += bezier(v1x2,v1y2,v1x2,hy1,hx1,hy1);
		path += line(hx1,hy1,hx2,hy2);
		path += bezier(hx2,hy2,v2x1,hy2,v2x1,v2y1);
		path += line(v2x1,v2y1,v2x2,v2y2);
		path += bezier(v2x2,v2y2,v2x2,y2,v2x2+cr2,y2);
		path += line(v2x2+cr2,y2,x2,y2);
	}
	else if( c.type == 1 ){
		var cr = this.curveRadius;
		if( this.config.options.rtl ){
			cr *= -1;
		}
		var link = c.links[0];
		path += line(x1,y1,link.x1-cr,y1);
		path += bezier(link.x1-cr,y1,link.x1,y1,link.x1,link.y1 + s1);
		path += line(link.x1,link.y1 + s1,link.x2,link.y2 + s2);
		path += bezier(link.x2,link.y2 + s2,link.x2,y2,link.x2+cr,y2);
		path += line(link.x2+cr,y2,x2,y2);
	}
	return path;
}

/**
 * Getter for connection between <v1> and <v2>
 */
TRAViz.prototype.getConnection = function(v1,v2){
	for( var i=0; i<this.connections.length; i++ ){
		if( this.connections[i].v1 == v1 && this.connections[i].v2 == v2 ){
			return this.connections[i];
		}
	}
	return false;
}

/**
 * Displays all paths that run through the given <vertex>
 */
TRAViz.prototype.displayVertexConnections = function(node,vertex){
	this.vertexConnections = [];
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].ins = [];
		this.vertices[i].outs = [];
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=0; j<p.length; j++ ){
			if( p[j] == vertex ){
				for( var j=0; j<p.length; j++ ){
					if( j>0 ){
						p[j].ins.push({
							v: p[j-1],
							id: i
						});
					}
					if( j<p.length-1 ){
						p[j].outs.push({
							v: p[j+1],
							id: i
						});
					}
				}
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var yv = (v.y1+v.y2)/2;
		if( this.vertices[i].token == "" && ( this.vertices[i].ins.length <= 1 || this.vertices[i].outs.length <= 1 ) ){
			this.vertices[i].ins = [{}];
			this.vertices[i].outs = [{}];
		}
		this.vertices[i].ins.sort(function(t1,t2){			
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 > t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
		this.vertices[i].outs.sort(function(t1,t2){
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 < t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
	}
	var getShift = function(id,array){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return i*3 - array.length*3/2;
			}
		}
	}
	var getShiftHeight = function(id,array,height){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return (i*3 - array.length*3/2)/(array.length*2)*height/2;
			}
		}
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		for( var j=0; j<p.length; j++ ){
			if( p[j] == vertex ){
				var path = "";
				for( var j=1; j<p.length; j++ ){
					var c = this.getConnection(p[j-1],p[j]);
					if( c ){
						if( this.config.options.interpolateFontSize ){
							path += this.generatePath(c,getShiftHeight(i,p[j-1].outs,p[j-1].boxHeight),getShiftHeight(i,p[j].ins,p[j].boxHeight));
						}
						else {
							path += this.generatePath(c,getShift(i,p[j-1].outs),getShift(i,p[j].ins));
						}
					}
				}
				var pvis = this.paper.path(path).attr({stroke: this.colorMap[this.editions[i]], "stroke-width": 3, "stroke-linecap": "round", "opacity": "0.8"});
				this.vertexConnections.push(pvis);
				break;
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( v == this.startVertex || v == this.endVertex || v.token == '' ){
			continue;
		}
		if( this.config.options.vertexBackground ){
			v.rect.toFront();
		}
		if( v.count > this.config.options.collapseLabels ){
			v.textNode.toFront();
		}
	}
};

/**
 * Displays all connections and in case of majority=true, all majority edges are bundled
 */
TRAViz.prototype.majorityConnections = function(majority){
	var edges = [];
	for( var i=0; i<this.vertices.length; i++ ){
		for( var j=0; j<this.vertices[i].successors.length; j++ ){
			edges.push({
				head: this.vertices[i],
				tail: this.graph.getVertex(this.vertices[i].successors[j]),
				weight: 0,
				ids: []
			});
		}
	}
	var weightEdge = function(v1,v2,id){
		for( var i=0; i<edges.length; i++ ){
			var e = edges[i];
			if( e.head == v1 && e.tail == v2 ){
				e.weight++;
				e.ids.push(id);
			}
		}
	}
	for( var i=0; i<this.sentencePaths.length; i++ ){
		var p = this.sentencePaths[i];
		weightEdge(this.startVertex,p[0],i);
		weightEdge(p[p.length-1],this.endVertex,i);
		for( var j=0; j<p.length-1; j++ ){
			weightEdge(p[j],p[j+1],i);
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].ins = [];
		this.vertices[i].outs = [];
	}
	for( var i=0; i<edges.length; i++ ){
		var e = edges[i];
		if( majority && e.weight > this.sentencePaths.length * this.config.options.majorityPercentage ){
			e.head.outs.push({
				v: e.tail,
				id: -1
			});
			e.tail.ins.push({
				v: e.head,
				id: -1
			});
		}
		else {
			for( var j=0; j<e.ids.length; j++ ){
				e.head.outs.push({
					v: e.tail,
					id: e.ids[j]
				});
				e.tail.ins.push({
					v: e.head,
					id: e.ids[j]
				});
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		var yv = (v.y1+v.y2)/2;
		if( this.vertices[i].token == "" && ( this.vertices[i].ins.length <= 1 || this.vertices[i].outs.length <= 1 ) ){
			this.vertices[i].ins = [{}];
			this.vertices[i].outs = [{}];
		}
		this.vertices[i].ins.sort(function(t1,t2){			
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 > t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
		this.vertices[i].outs.sort(function(t1,t2){
			var y1 = (t1.v.y1+t1.v.y2)/2;
			var y2 = (t2.v.y1+t2.v.y2)/2;
			if( t1.v == t2.v && t1.id > t2.id ){
				return 1;
			}
			else if( t1.v != t2.v && y1 == y2 && t1.v.x2 < t2.v.x2 ){
				return 1;
			}
			else if( t1.v != t2.v && y1 > y2 ){
				return 1;
			}
			return -1;
		});
	}
	var getShift = function(id,array){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return i*3 - array.length*3/2;
			}
		}
	}
	var getShiftHeight = function(id,array,height){
		if( array.length == 1 ){
			return 0;
		}
		for( var i=0; i<array.length; i++ ){
			if( array[i].id == id ){
				return (i*3 - array.length*3/2)/(array.length*2)*height/2;
			}
		}
	}
	for( var i=0; i<edges.length; i++ ){
		var e = edges[i];
		var c = this.getConnection(e.head,e.tail);
		if( !c ){
			continue;
		}
		if( majority && e.weight > this.sentencePaths.length*this.config.options.majorityPercentage ){
			var path = null;
			if( this.config.options.interpolateFontSize ){
				path = this.generatePath(c,getShiftHeight(-1,e.head.outs,e.head.boxHeight),getShiftHeight(-1,e.tail.ins,e.tail.boxHeight));
			}
			else {
				path = this.generatePath(c,getShift(-1,e.head.outs),getShift(-1,e.tail.ins));
			}
			var pvis = this.paper.path(path).attr({stroke: this.config.options.baseColor, "stroke-width": 5, "stroke-linecap": "round", "opacity": "0.8"});
			this.addEdgeToGroup(e.head,e.tail,pvis,e.ids);
			this.basicConnections.push(pvis);
		}
		else {
			for( var j=0; j<e.ids.length; j++ ){
				var path = null;
				if( this.config.options.interpolateFontSize ){
					path = this.generatePath(c,getShiftHeight(e.ids[j],e.head.outs,e.head.boxHeight),getShiftHeight(e.ids[j],e.tail.ins,e.tail.boxHeight));
				}
				else {
					path = this.generatePath(c,getShift(e.ids[j],e.head.outs),getShift(e.ids[j],e.tail.ins));
				}
				var pvis = this.paper.path(path).attr({stroke: this.colorMap[this.editions[e.ids[j]]], "stroke-width": 3, "stroke-linecap": "round", "opacity": "0.8"});
				this.addEdgeToGroup(e.head,e.tail,pvis,[e.ids[j]]);
				this.basicConnections.push(pvis);
			}
		}
	}
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( v == this.startVertex || v == this.endVertex || v.token == '' ){
			continue;
		}
		if( this.config.options.vertexBackground ){
			v.rect.toFront();
		}
		if( v.count > this.config.options.collapseLabels ){
			v.textNode.toFront();
		}
	}
};

/**
 * Aligns all vertices horizontally, so that all overlaps are removed and a minimum gap between adjacent is given.
 */
TRAViz.prototype.setXFlow = function(){
	var gap = 4*this.curveRadius;
	var edges = [];
	for( var i=0; i<this.startVertex.successors.length; i++ ){
		edges.push({
			head: this.startVertex,
			tail: this.graph.getVertex(this.startVertex.successors[i])
		});
	}
	var widthS = this.startVertex.boxWidth;
	this.startVertex.x1 = gap;
	this.startVertex.x2 = gap + widthS;
	while( edges.length > 0 ){
		var new_edges = [];
		for( var i=0; i<edges.length; i++ ){
			var e = edges[i];
			var g = gap;
			if( e.tail.x1 < e.head.x2 + g ){
				e.tail.x1 = e.head.x2 + g;
				e.tail.x2 = e.head.x2 + g + e.tail.boxWidth;
				for( var j=0; j<e.tail.successors.length; j++ ){
					new_edges.push({
						head: e.tail,
						tail: this.graph.getVertex(e.tail.successors[j])
					});
				}
			}
		}
		edges = new_edges;
	}
	var largestMove = 3;
	while( largestMove > 2 ){
		largestMove = 0;
		for( var i=0; i<this.vertices.length; i++ ){
			var v = this.vertices[i];
			if( v == this.startVertex || v == this.endVertex ){
				continue;
			}
			var x_old = Math.floor(( v.x2 + v.x1 ) / 2);
			var w = v.boxWidth;
			var x_left = undefined, x_right = undefined;
			for( var j=0; j<v.predecessors.length; j++ ){
				var vp = this.graph.getVertex(v.predecessors[j]);
				var xp = vp.x2;
				if( vp == this.startVertex && !this.config.options.startAndEnd ){
					x_left = Math.floor(v.x1 - gap);
				}
				if( typeof x_left == "undefined" || xp > x_left ){
					x_left = xp;
				}
			}
			for( var j=0; j<v.successors.length; j++ ){
				var vs = this.graph.getVertex(v.successors[j]);
				var xs = vs.x1;
				if( vs == this.endVertex && !this.config.options.startAndEnd ){
					x_right = Math.floor(v.x2 + gap);
				}
				if( typeof x_right == "undefined" || xs < x_right ){
					x_right = xs;
					xr = vs;
				}
			}
			var x_new = Math.floor(( x_left + x_right ) / 2);
			if( isNaN(x_new) ){
				x_new = x_old;
			}
			if( x_new != x_old ){
				v.x1 = x_new - w/2;
				v.x2 = v.x1 + w;
				if( largestMove < Math.abs(x_new-x_old) ){
					largestMove = Math.abs(x_new-x_old);
				}
			}
		}
	}
};

/**
 * Test if the given bounds overlap each other.
 */
TRAViz.prototype.overlap = function(x1_min,x1_max,x2_min,x2_max,y1_min,y1_max,y2_min,y2_max){
	if( x1_min >= x2_max || x1_max <= x2_min || y1_min >= y2_max || y1_max <= y2_min ){
		return false;
	}
	return true;
}

/**
 * Getter for the layer with the given <index>
 */
TRAViz.prototype.getLayer = function(index){
	for( var i=0; i<this.layers.length; i++ ){
		if( this.layers[i].index == index ){
			return this.layers[i];
		}
	}
	return false;
}

/**
 * Getter for the array_index for the layer with the given <index>
 */
TRAViz.prototype.getLayerIndex = function(index){
	for( var i=0; i<this.layers.length; i++ ){
		if( this.layers[i].index == index ){
			return i;
		}
	}
	return false;
}

/**
 * Computes all connections dependent on the current vertex positions.
 */
TRAViz.prototype.setConnections = function(){
	this.prepareConnections();
	var y = 1000;
	for( var i=0; i<this.layers.length; i++ ){
		this.horizontalSlots[i].yMin = y+this.curveRadius;
		this.horizontalSlots[i].yMax = y-this.curveRadius+this.horizontalSlots[i].height;
		y += this.layers[i].height/2 + this.horizontalSlots[i].height;
		this.layers[i].yLevel = 0+y;
		for( var j=0; j<this.layers[i].vertices.length; j++ ){
			var heightN = this.layers[i].vertices[j].boxHeight;
			this.layers[i].vertices[j].y1 = y - heightN / 2;
			this.layers[i].vertices[j].y2 = y + heightN / 2;
		}
		y += this.layers[i].height/2;
	}
	this.adjustHorizontalConnections();
	this.adjustVerticalConnections();
}

/**
 * In case of line breaks, dummys are inserted at the end and the start of a line to help connect adjacent vertices.
 */
TRAViz.prototype.insertDummys = function(){
	var gap = 3*this.curveRadius;
	var width = $('#'+this.div).width();
	var sortByX = function(v1,v2){
		if( v1.x1 < v2.x1 ){
			return -1;
		}
		return 1;
	}
	this.vertices.sort(sortByX);
	var shift = this.vertices[0].x1 - gap;
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].x1 -= shift;
		this.vertices[i].x2 -= shift;
		this.vertices[i].x1Temp = this.vertices[i].x1;
		this.vertices[i].x2Temp = this.vertices[i].x2;
	}
	var verticesToCheck = this.vertices;
	var level = 0;
	while( verticesToCheck.length > 0 ){
		var vtc = [];
		var shift = 0;
		var tshift = 0;
		for( var i=0; i<verticesToCheck.length; i++ ){
			if( verticesToCheck[i].x2Temp + 2*gap > width ){
				if( shift == 0 ){
					shift = 3*gap - verticesToCheck[i].x1Temp;
					verticesToCheck[i].x2Temp = verticesToCheck[i].x2Temp - verticesToCheck[i].x1Temp + 3*gap;
					verticesToCheck[i].x1Temp = 3*gap;
					tshift = (level+1)*width - verticesToCheck[i].x1 + 3*gap;
				}
				else {
					verticesToCheck[i].x1Temp += shift;
					verticesToCheck[i].x2Temp += shift;
				}
				verticesToCheck[i].x1 += tshift;
				verticesToCheck[i].x2 += tshift;
				vtc.push(verticesToCheck[i]);
			}
			else {
				verticesToCheck[i].level = level;
			}
		}
		verticesToCheck = vtc;
		level++;
	}
	var dummys = [];
	var edges = [];
	for( var i=0; i<this.vertices.length; i++ ){
		for( var j=0; j<this.vertices[i].successors.length; j++ ){
			edges.push({
				head: this.vertices[i],
				tail: this.graph.getVertex(this.vertices[i].successors[j])
			});
		}
	}
	var paths = [];
	for( var i=0; i<edges.length; i++ ){
		var e = edges[i];
		if( e.tail.level != e.head.level ){
			var dvh, dvt;
			if( typeof dummys[e.tail.index+''] == 'undefined' ){
				dvh = new TRAVizVertex(this.graph,this.config.getVertexIndex(),'');
				dvh.dummy = true;
				dvh.predecessors = [e.head.index];
				e.head.removeSuccessor(e.tail.index);
				e.head.addSuccessor(dvh.index);
				dvt = new TRAVizVertex(this.graph,this.config.getVertexIndex(),'');
				dvt.dummy = true;
				dvt.successors = [e.tail.index];
				e.tail.removePredecessor(e.head.index);
				e.tail.addPredecessor(dvt.index);					
				dvh.addSuccessor(dvt.index);
				dvt.addPredecessor(dvh.index);
				dvh.boxWidth = 0, dvh.boxHeight = 0;
				dvt.boxWidth = 0, dvt.boxHeight = 0;
				dvh.x1Temp = width - gap, dvh.x2Temp = width - gap;
				dvt.x1Temp = gap, dvt.x2Temp = gap;
				dvh.x1 = (e.head.level+1)*width, dvh.x2 = (e.head.level+1)*width;
				dvt.x1 = (e.head.level+1)*width, dvt.x2 = (e.head.level+1)*width;
				var path = [e.head,dvh,dvt,e.tail];
				paths.push(path);
				this.graph.addVertex(dvh);
				this.graph.addVertex(dvt);
				dvh.level = e.head.level;
				dvt.level = e.head.level + 1;
				this.layout.push(dvh);
				this.layout.push(dvt);
				if( e.head.token == "" ){
					dvh.linebreak = true;
				}
				if( e.tail.level != dvt.level ){						
					edges.splice(i+1,0,{
						head: dvt,
						tail: e.tail
					});
				}
				else {
					dummys[e.tail.index+''] = { h: dvh, t: dvt, path: path };
				}
			}
			else {
				dvh = dummys[e.tail.index+''].h;
				dvt = dummys[e.tail.index+''].t;
				e.head.removeSuccessor(e.tail.index);
				e.head.addSuccessor(dvh.index);
				e.tail.removePredecessor(e.head.index);
				e.tail.addPredecessor(dvt.index);
				dvh.addPredecessor(e.head.index);
				var path = dummys[e.tail.index+''].path;
				if( Math.abs(e.head.layer) < Math.abs(path[0].layer) || Math.abs(e.head.layer) == Math.abs(path[0].layer) && e.head.x2 > path[0].x2 ){
					path[0] = e.head;
				}
			}
			for( var j=0; j<this.sentencePaths.length; j++ ){
				for( var k=0; k<this.sentencePaths[j].length-1; k++ ){
					if( this.sentencePaths[j][k] == e.head && this.sentencePaths[j][k+1] == e.tail ){
						this.sentencePaths[j].splice(k+1,0,dvh,dvt);
						break;
					}
				}
			}
		}
	}
	var sortPaths = function(p1,p2){
		if( p1[0].level < p2[0].level ){
			return -1;
		}
		if( Math.abs(p1[0].layer+p1[3].layer) < Math.abs(p2[0].layer+p2[3].layer) ){
			return -1;
		}
		if( Math.abs(p1[0].layer+p1[3].layer) == Math.abs(p2[0].layer+p2[3].layer) && p1[3].x1-p1[0].x2 < p2[3].x1-p2[0].x2 ){
			return -1;
		}
		return 1;
	}
	paths.sort(sortPaths);
	for( var i=0; i<paths.length; i++ ){
		var path = paths[i];
		var layer = this.getYLayer(path[0].layer,path[3].layer,path[1],true);
		path[1].layer = layer;
		path[2].layer = layer;
	}
	for( var i=0; i<this.vertices.length; i++ ){
		this.vertices[i].x1 = this.vertices[i].x1Temp;
		this.vertices[i].x2 = this.vertices[i].x2Temp;
	}
	this.vertices = this.graph.vertices;
}

/**
 * Draw the edition with <id> on the main branch (all vertices of edition <id> will appear on the same horizontal level).
 */
TRAViz.prototype.setMainBranch = function(id){
	if( this.mainBranch != id ){
		this.mainBranch = id;
		this.reset();
		this.visualize();
	}
};

/**
 * Computes the path of the given transposition between <v1> and <v2>
 */
TRAViz.prototype.generateTranspositionPath = function(v1,v2){
	var bezier = function(x1,y1,xb,yb,x2,y2){
		return "C "+x1+" "+y1+" "+xb+" "+yb+" "+x2+" "+y2+" ";
	}
	var line = function(x1,y1,x2,y2){
		return "L "+x1+" "+y1+" "+x2+" "+y2+" ";
	}
	var x1 = v1.x, x2 = v2.x;
	var y1, y2, y3, y4, y5;
	var l1 = this.getLayer(v1.layer);
	var l2 = this.getLayer(v2.layer);
	var cr = Math.min(this.curveRadius,Math.abs(x1-x2)/2);
	if( l1 == l2 ){
		var y1 = v1.y2;
		var y2 = (v1.y1+v1.y2)/2 + l1.height/2;
		var y3 = (v1.y1+v1.y2)/2 + l1.height/2 + cr;		
		var y4 = (v2.y1+v2.y2)/2 + l1.height/2;
		var y5 = v2.y2;
	}
	else if( l1.index < l2.index ){
		var hsh = this.horizontalSlots[this.getLayerIndex(v1.layer)+1].yMax - this.horizontalSlots[this.getLayerIndex(v1.layer)+1].yMin;
		var y1 = v1.y2;
		var y2 = (v1.y1+v1.y2)/2 + l1.height/2 + hsh/2;
		var y3 = (v1.y1+v1.y2)/2 + l1.height/2 + hsh/2 + cr;		
		var y4 = y3 + cr;
		var y5 = v2.y1;
	}
	else if( l1.index > l2.index ){
		var hsh = this.horizontalSlots[this.getLayerIndex(v1.layer)].yMax - this.horizontalSlots[this.getLayerIndex(v1.layer)].yMin;
		var y1 = v1.y1;
		var y2 = (v1.y1+v1.y2)/2 - l1.height/2 - hsh/2;
		var y3 = (v1.y1+v1.y2)/2 - l1.height/2 - hsh/2 - cr;		
		var y4 = y3 - cr;
		var y5 = v2.y2;
	}
	var path = "M "+x1+" "+y1+" ";
	path += line(x1,y1,x1,y2);
	path += bezier(x1,y2,x1,y3,x1+cr,y3);
	path += line(x1+cr,y3,x2-cr,y3);
	path += bezier(x2-cr,y3,x2,y3,x2,y4);
	path += line(x2,y4,x2,y5);
	return path;	
}

/**
 * Calculates minimum spanning trees for (potential) transpositions.
 */
TRAViz.prototype.calculateTranspositions = function(){
	var groups = [];
	for( var i=0; i<this.vertices.length; i++ ){
		if( this.vertices[i] == this.startVertex || this.vertices[i] == this.endVertex || this.vertices[i].token == '' ){
			continue;
		}
		this.vertices[i].x = (this.vertices[i].x1+this.vertices[i].x2)/2;
		var found = false;
		for( var j=0; j<groups.length; j++ ){
			if( groups[j][0].token == this.vertices[i].token ){
				groups[j].push(this.vertices[i]);
				found = true;
				break;
			}
		}
/*
		if( this.config.options.editDistance ){
			for( var j=0; j<groups.length; j++ ){
				var g = groups[j];
				for( var k=0; k<g.length; k++ ){
					for( var l=0; l<g[k].sources.length; l++ ){
						for( var m=0; m<this.vertices[i].sources.length; m++ ){
							var ld = this.aligner.getEditDistance(g[k].sources[l].token,this.vertices[i].sources[m].token);
							var red = 2*ld / (g[k].sources[l].token.length+this.vertices[i].sources[m].token.length);
							if( red <= this.config.options.editDistance ){
								groups[j].push(this.vertices[i]);
								found = true;
								break;
							}
						}
					}
				}
			}
		}
*/
		if( !found ){
			groups.push([this.vertices[i]]);
		}
	}
	for( var i=0; i<groups.length; i++ ){
		var g = groups[i];
		if( g.length == 1 ){
			continue;
		}
		for( var j=0; j<g.length; j++ ){
			g[j].transpositions = [];
			g[j].transpositionGroup = g;
			for( var k=0; k<g.length; k++ ){
				if( j == k ){
					continue;
				}
				var path = "";
				if( g[j].x < g[k].x ){
					path = this.generateTranspositionPath(g[j],g[k]);
				}
				else {
					path = this.generateTranspositionPath(g[k],g[j]);
				}
				var p = this.paper.path(path).attr({"stroke-width": 3, "stroke-dasharray":'.', "opacity": "1.0"});
				$(p.node).css('display','none');
				g[j].transpositions.push(p);
			}
		}
	}
	/*
	var distance = function(v1,v2){
		var x1 = (v1.x1 + v1.x2)/2;
		var y1 = (v1.y1 + v1.y2)/2;
		var x2 = (v2.x1 + v2.x2)/2;
		var y2 = (v2.y1 + v2.y2)/2;
		v1.x = x1;
		v1.y = y1;
		v2.x = x2;
		v2.y = y2;
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}
	for( var i=0; i<groups.length; i++ ){
		var g = groups[i];
		if( g.length == 1 ){
			continue;
		}
		var matrix = new AdjMatrix(g.length);
		for (var k = 0; k < g.length - 1; k++) {
			for (var l = k + 1; l < g.length; l++) {
				matrix.setEdge( k, l, distance(g[k],g[l]) );
			}
		}
		var tree = Prim(matrix);
		var paths = [];
		for (var z = 0; z < tree.length; z++) {
			var v1 = g[tree[z].v1];
			var v2 = g[tree[z].v2];			
			var path = "";
			if( v1.x < v2.x ){
				path = this.generateTranspositionPath(v1,v2);
			}
			else {
				path = this.generateTranspositionPath(v2,v1);
			}
			var p = this.paper.path(path).attr({"stroke-width": 4, "stroke-dasharray":'.', "opacity": "1.0"});
			$(p.node).css('display','none');
			paths.push(p);
		}
		for( var j=0; j<g.length; j++ ){
			g[j].transpositions = paths;
		}
	}
	*/
};

/**
 * Main funtion to be called to visualize the computed Text Variant Graph.
 */
TRAViz.prototype.visualize = function(){
	if( this.config.options.lineBreaks ){
		if( $('#'+this.div).width() == 0 ){
			this.config.options.lineBreaks = false;
			alert('Please check the width of your container div!');
		}
	}
	var qtips = $('.trailsQtip');
	for( var i=0; i<qtips.length; i++ ){
		$(qtips[i]).remove();
	}
	var gap = 2*this.curveRadius;
	var sal = this;
	var layerHeights = [];
	var paths = this.aligner.getPathsByEdition(this.sentencePathHash[this.mainBranch],this.sentencePaths);
	var heights = [];
	$("#"+this.div).empty();
	var x, y = 1000;
	var getMousePosition = function(event) {
		if (!event) {
			event = window.event;
		}
		var body = (window.document.compatMode && window.document.compatMode == "CSS1Compat") ? window.document.documentElement : window.document.body;
		return {
			top : event.pageY ? event.pageY : event.clientY,
			left : event.pageX ? event.pageX : event.clientX
		};
	};
	var dragNode = function(evt,node,vertex){
		var startPos = getMousePosition(evt);
		var nodeX1 = vertex.x1;
		var nodeX2 = vertex.x2;
		var nodeY1 = vertex.y1;
		var nodeY2 = vertex.y2;
		var clone = false;
		var mergeNode = false, acyclic = false;
		document.onmouseup = function(){
			if(document.selection && document.selection.empty) {
				document.selection.empty();
			}
			else if(window.getSelection){
				var sel = window.getSelection();
				sel.removeAllRanges();
			}
			document.onmousemove = null;
			document.onmouseup = null;
			if( mergeNode && !acyclic ){
				alert('Invalid merge attempt produced a circle in the graph!');
				clone.attr({ fill : sal.config.options.baseColor });
				mergeNode.textNode.attr({ fill : sal.config.options.baseColor });
				$(clone.node).fadeOut(1000, function(){
					$(clone).remove();
				});
			}
			else if( mergeNode && acyclic ){
				var v = sal.originGraph.isAcyclicFromVertex(sal.originGraph.getVertex(mergeNode.index),sal.originGraph.getVertex(vertex.index));
				for( var i=0; i<sal.sentencePaths.length; i++ ){
					var p = sal.sentencePaths[i];
					for( var j=0; j<p.length; j++ ){
						if( p[j] == mergeNode || p[j] == vertex ){
							p[j] = v;
						}
					}
				}
				sal.reset();
				sal.visualize();
			}
			else {
				$(clone.node).fadeOut(1000, function(){
					$(clone).remove();
				});
			}
		}
		document.onmousemove = function(e){
			if( !clone ){
				clone = sal.paper.text(( vertex.x1 + vertex.x2 )/2, ( vertex.y1 + vertex.y2 )/2, vertex.token).attr({font: vertex.fs+"px "+sal.config.options.font,fill:sal.config.options.baseColor,"text-anchor":"middle","cursor":"pointer"});
			}
			if(document.selection && document.selection.empty) {
				document.selection.empty();
			}
			else if(window.getSelection){
				var sel = window.getSelection();
				sel.removeAllRanges();
			}
			var pos = getMousePosition(e);
			clone.x1 = nodeX1+pos.left-startPos.left;
			clone.x2 = nodeX2+pos.left-startPos.left;
			clone.y1 = nodeY1+pos.top-startPos.top;
			clone.y2 = nodeY2+pos.top-startPos.top;
			clone.attr({ x: (clone.x1 + clone.x2)/2, y: ( clone.y1 + clone.y2 )/2 });
			if( mergeNode ){
				clone.attr({ fill : sal.config.options.baseColor });
				mergeNode.textNode.attr({ fill : sal.config.options.baseColor });
			}
			mergeNode = false;
			acyclic = false;
			var d = 0;
			for( var i=0; i<sal.vertices.length; i++ ){
				var v1 = clone;
				var v2 = sal.vertices[i];
				if( vertex != v2 && sal.overlap(v1.x1,v1.x2,v2.x1,v2.x2,v1.y1,v1.y2,v2.y1,v2.y2) ){
					var x1 = (v1.x1+v1.x2)/2;
					var x2 = (v2.x1+v2.x2)/2;
					var y1 = (v1.y1+v1.y2)/2;
					var y2 = (v2.y1+v2.y2)/2;
					var dist = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
					if( !mergeNode || mergeNode && dist < d ){
						mergeNode = v2;
						d = dist;
					}
				}
			}
			if( mergeNode ){
				var color = null;
				var g_test = sal.originGraph.clone();
				acyclic = g_test.isAcyclicFromVertex(sal.originGraph.getVertex(mergeNode.index),sal.originGraph.getVertex(vertex.index));
				acyclic ? color = "#90EE90" : color = "#FF8AA7";
				clone.attr({ fill: color });
				mergeNode.textNode.attr({ fill: color });
			}
		}
	}
	var createBranch = function(v,e){
		var nv = new TRAVizVertex(sal.originGraph,sal.originGraph.config.getVertexIndex());
		sal.originGraph.addVertex(nv);
		for( var i=0; i<v.sources.length; i++ ){
			if( v.sources[i].sourceId == e ){
				nv.sources.push(v.sources[i]);
				nv.token = v.sources[i].token;
				v.sources.splice(i,1);
				break;
			}
		}
		v.count--;
		var sp = sal.sentencePaths[e];
		for( var i=0; i<sp.length; i++ ){
			if( sp[i].index == v.index ){
				sp[i] = nv;
				break;
			}
		}
		sal.reset();
		sal.visualize();
	}
	var setTooltip = function(node,vertex,paper){
		var attachedLinks = false;
		node.connections = [];
		var showConnections = function(){
			for( var i=0; i<sal.basicConnections.length; i++ ){
				$(sal.basicConnections[i].node).css('display','none');
			}
			for( var i=0; i<sal.vertexConnections.length; i++ ){
				$(sal.vertexConnections[i].node).remove();
			}
			sal.displayVertexConnections(node,vertex,paper);
			if( vertex.transpositions ){
				for( var i=0; i<vertex.transpositions.length; i++ ){
					$(vertex.transpositions[i].node).css('display','block');
				}
				for( var i=0; i<vertex.transpositionGroup.length; i++ ){
					$(vertex.transpositionGroup[i].rect.node).attr({"stroke":"#000", "stroke-width": 1, "opacity": "1.0"});
				}
			}
		}
		var hideConnections = function(){
			for( var i=0; i<sal.vertexConnections.length; i++ ){
				$(sal.vertexConnections[i].node).remove();
			}
			for( var i=0; i<sal.basicConnections.length; i++ ){
				$(sal.basicConnections[i].node).css('display','block');
			}
			if( vertex.transpositions ){
				for( var i=0; i<vertex.transpositions.length; i++ ){
					$(vertex.transpositions[i].node).css('display','none');
				}
				for( var i=0; i<vertex.transpositionGroup.length; i++ ){
					$(vertex.transpositionGroup[i].rect.node).attr({"stroke":"none"});
				}
			}
		}
		$(node).mouseenter(function(){
			showConnections();
		});
		$(node).mouseleave(function(){
			hideConnections();
		});
		if( sal.config.options.splitAndMerge ){
			$(node).mousedown(function(evt){
				dragNode(evt,node,vertex);
			});
		}
		var tiptext = "<table>";
		tiptext += "<tr><th style='padding:5px;text-align:right;'>Figure</th><th style='padding:5px;text-align:right;'>Episode</th></tr>";
		for( var i=0; i<vertex.sources.length; i++ ){
			tiptext += "<tr>";
			tiptext += "<td style='padding:5px;text-align:right;color:"+sal.colorMap[sal.editions[vertex.sources[i].sourceId]]+";'>"+sal.editions[vertex.sources[i].sourceId]+"</td>";
			tiptext += "<td style='padding:5px;text-align:left;color:"+sal.colorMap[sal.editions[vertex.sources[i].sourceId]]+";'>"+vertex.sources[i].token+"</td>";
			if( sal.config.options.splitAndMerge && vertex.sources.length > 1 ){
				tiptext += "<td><div title='Remove token and create new branch!' name="+vertex.sources[i].sourceId+" class='unlink unlink"+vertex.index+"'/></td>";
			}
			tiptext += "</tr>";
		}
		tiptext += "</table>";
		$(node).qtip({
			content: {	
				text: tiptext,
				title: {
					text: "<div>\""+vertex.token+"\": "+vertex.sources.length+"&nbsp;"+sal.config.options.popupLabel+"</div>",
					button: '&#10006'
				}
			},
			style: {
				tip: true,
				border: { width: 0, radius: 3 }
			},
			position: {
				corner: {
					tooltip: "topMiddle",
					target: "bottomMiddle"
				}
			},
			show: {
				when: 'click', 
				solo: true
			},
			hide: {
				when: { event: 'click' }
			},
			api: {
				onShow: function(){
					$("[qtip='"+this.id+"']").addClass('trailsQtip');
					$("[qtip='"+this.id+"']").mouseenter(function(){
						showConnections();
					});
					$("[qtip='"+this.id+"']").mouseleave(function(){
						hideConnections();
					});
					if( $(".qtip-content","[qtip='"+this.id+"']").height() > 200 ){
						$(".qtip-content","[qtip='"+this.id+"']").css('height','200px');
						$(".qtip-content","[qtip='"+this.id+"']").css('overflow','auto');
					}
					if( !attachedLinks ){
						var links = $('.unlink'+vertex.index);
						if( links.length > 0 ){
							for( var i=0; i<links.length; i++ ){
								$(links[i]).click(function(){
									createBranch(sal.originGraph.getVertex(vertex.index),$(this).attr('name'));
								});
							}
							attachedLinks = true;
						}
					}
				},
				onHide: function(){
					hideConnections();
				}
			}
		});
	}
	var helperDiv = $('<label/>').appendTo('body');
	var t1 = new Date();
	this.layout = [];
	var maxLabel = 0;
	for( var i=0; i<this.vertices.length; i++ ){
		if( this.vertices[i].count > maxLabel ){
			maxLabel = this.vertices[i].count;
		}
	}
	for( var i=0; i<paths.length; i++ ){
		x = 0;
		var j=0, k=paths[i].length;
		if( i > 0 ){
			j++;
			k--;
		}
		var width = 0, height = 0;
		var sizes = [ 12, 17, 23, 30, 38, 47, 57 ];
		for( j; j<k; j++ ){
			var v = paths[i][j];
			var fs = this.config.options.fontSizeMin + this.config.options.fontSizeIncrease*(v.count-1);
			if( this.config.options.interpolateFontSize ){
				fs = this.config.options.fontSizeMin + (v.count-1)/(maxLabel-1) * (this.config.options.fontSizeMax - this.config.options.fontSizeMin);
			}
			$(helperDiv).html(v.token);
			$(helperDiv).css("font",fs+"px "+this.config.options.font);
			v.x1 = x;
			if( v.count <= this.config.options.collapseLabels ){
				$(helperDiv).html("M");
			}
			var widthN = $(helperDiv).width() + 6;
			var heightN = $(helperDiv).height();
			v.boxWidth = widthN;
			v.boxHeight = heightN;
			v.x2 = widthN + x;
			v.y1 = y - heightN/2;
			v.y2 = y + heightN/2;
			width += widthN;
			if( j > 0 ){
				width += gap;
			}
			if( heightN > height ){
				height = heightN;
			}
			this.layout.push(v);
		}
		heights.push(height);
	}
	$(helperDiv).remove();
	this.setXFlow();
	var paperDiv = $("<div id='TRAVizPaperDiv"+this.div+"'/>").appendTo('#'+this.div);
	var r = Raphael('TRAVizPaperDiv'+this.div,10000,10000);
	this.layout = [];
	this.layers = [];
	var lh = 0;
	for( var i=0; i<paths[0].length; i++ ){
		this.layout.push(paths[0][i]);
		paths[0][i].layer = 0;
		if( paths[0][i].boxHeight > lh ){
			lh = paths[0][i].boxHeight;
		}
	}
	this.layers.push({
		index: 0,
		height: lh,
		vertices: []
	});
	this.getYLayer = function(layer0,layerN,v,force){
		var destination = layerN;
		if( Math.abs(layer0) > Math.abs(layerN) ){
			destination = layer0;
		}
		var destinationStart = destination;
		var next = function(add){
			if( typeof add != "undefined" ){
				if( add > 0 ){
					add *= -1;
				}
				else {
					add = add*-1+1;
				}
				destination = destinationStart + add;
			}
			else {
				add = 0;
			}
			if( !force && destination == 0 ){
				next(add);
			}
			else {
				var overlaps = false;
				for( var i=0; i<sal.layout.length; i++ ){
					if( sal.layout[i].layer == destination ){
						if( !( sal.layout[i].x1 > v.x2 || v.x1 > sal.layout[i].x2 ) ){
							overlaps = true;
							break;
						}
					}
				}
				if( overlaps ){
					next(add);
				}
			}
		}
		next();
		var layer = this.getLayer(destination);
		if( !layer ){
			layer = {
				index: destination,
				height: 0,
				vertices: []
			};
			this.layers.push(layer);
		}
		if( Math.abs(v.y2-v.y1) > layer.height ){
			layer.height = Math.abs(v.y2-v.y1);
		}
		return destination;
	}
	for( var i=1; i<paths.length; i++ ){
		var path = paths[i];
		var s = path[0];
		var e = path[path.length-1];
		var s1 = path[1];
		var e1 = path[path.length-2];
		var vertex = new TRAVizVertex();
		vertex.x1 = s1.x1 - gap;
		vertex.x2 = e1.x2 + gap;
		vertex.y1 = (s.y1 + s.y2)/2 - heights[i]/2;
		vertex.y2 = (s.y1 + s.y2)/2 + heights[i]/2;
		vertex.token = s1.token;
		var y = this.getYLayer(s.layer,e.layer,vertex);
		for( var j=1; j<path.length-1; j++ ){
			path[j].layer = y;
			this.layout.push(path[j]);
		}
	}
	if( this.config.options.lineBreaks ){
		this.insertDummys();
	}
	var ln = this.layers.length;
	for( var i=0; i<this.vertices.length; i++ ){
		var v = this.vertices[i];
		if( typeof v.level == "undefined" ){
			v.level = 0;
		}
		var oldLayer = this.getLayer(v.layer);
		v.originLayer = oldLayer.index;
		for( var j=0; j<oldLayer.vertices.length; j++ ){
			if( oldLayer.vertices[j] == v ){
				oldLayer.vertices.splice(j,1);
				break;
			}
		}
		v.layer += v.level * ln;
		var layer = this.getLayer(v.layer);
		if( !layer ){
			layer = {
				index: v.layer,
				height: 0,
				vertices: []
			};
			this.layers.push(layer);
		}
		if( Math.abs(v.y2-v.y1) > layer.height ){
			layer.height = Math.abs(v.y2-v.y1);
		}
		layer.vertices.push(v);
	}
	var sortLayers = function(l1,l2){
		if( l1.index < l2.index ){
			return -1;
		}
		return 1;
	}
	this.layers.sort(sortLayers);
	var lastLevel = 0;
	for( var i=0; i<this.layers.length; i++ ){
		if( this.layers[i].vertices.length > 0 ){
			this.layers[i].level = this.layers[i].vertices[0].level;
			lastLevel = this.layers[i].level;
		}
		else {
			this.layers[i].level = lastLevel;
		}
	}
	this.setConnections();
	this.removeOverlaps();
	this.transformEdgeTypes();
	if( this.config.options.lineBreaks && this.config.options.lineNumbering ){
		for( var i=0; i<this.layout.length; i++ ){
			var v = this.layout[i];
			v.y1 += (v.level+1)*26;
			v.y2 += (v.level+1)*26;
		}
		for( var i=0; i<this.connections.length; i++ ){
			var v = this.connections[i].v1;
			for( var j=0; j<this.connections[i].links.length; j++ ){
				this.connections[i].links[j].y1 += (v.level+1)*26;
				this.connections[i].links[j].y2 += (v.level+1)*26;
			}			
		}
		for( var i=0; i<this.layers.length; i++ ){
			this.layers[i].yLevel += (this.layers[i].level+1)*26;
		}
	}
	var nXs = false;
	for( var i=0; i<this.startVertex.successors.length; i++ ){
		var suc = this.graph.getVertex(this.startVertex.successors[i]);
		if( !nXs || suc.x1 - 4*this.curveRadius < nXs ){
			nXs = suc.x1 - 4*this.curveRadius;
		}
	}
	this.startVertex.x1 = nXs;
	this.startVertex.x2 = nXs;
	for( var i=0; i<this.startVertex.successors.length; i++ ){
		var c = this.getConnection(this.startVertex,this.graph.getVertex(this.startVertex.successors[i]));
		if( c.type == 1 && c.links[0].type == "source" ){
			c.links[0].x1 = nXs + this.curveRadius;
			c.links[0].x2 = nXs + this.curveRadius;
		}
		else if( c.type == 3 || c.type == 0 ){
			c.links[0].x1 = nXs + this.curveRadius;
			c.links[0].x2 = nXs + this.curveRadius;
			c.links[1].x1 = nXs + 2*this.curveRadius;
		}
	}
	var nXe = 0;
	for( var i=0; i<this.endVertex.predecessors.length; i++ ){
		var pred = this.graph.getVertex(this.endVertex.predecessors[i]);
		if( pred.x2 + 4*this.curveRadius > nXe ){
			nXe = pred.x2 + 4*this.curveRadius;
		}
	}
	this.endVertex.x1 = nXe;
	this.endVertex.x2 = nXe;
	for( var i=0; i<this.endVertex.predecessors.length; i++ ){
		var c = this.getConnection(this.graph.getVertex(this.endVertex.predecessors[i]),this.endVertex);
		if( c.type == 1 && c.links[0].type == "sink" ){
			c.links[0].x1 = nXe - this.curveRadius;
			c.links[0].x2 = nXe - this.curveRadius;
		}
		else if( c.type == 3 || c.type == 0 ){
			c.links[2].x1 = nXe - this.curveRadius;
			c.links[2].x2 = nXe - this.curveRadius;
			c.links[1].x2 = nXe - 2*this.curveRadius;
		}
	}
	var x_min = false, x_max = false;
	var y_min = false, y_max = false;
	if( this.config.options.rtl ){
		for( var i=0; i<this.layout.length; i++ ){
			this.layout[i].x1 *= -1;
			this.layout[i].x2 *= -1;
		}
		for( var i=0; i<this.connections.length; i++ ){
			for( var j=0; j<this.connections[i].links.length; j++ ){
				this.connections[i].links[j].x1 *= -1;
				this.connections[i].links[j].x2 *= -1;
			}			
		}
	}
	for( var i=0; i<this.layout.length; i++ ){
		var v = this.layout[i];
		if( !x_min || v.x1 < x_min ){
			x_min = v.x1;
		}
		if( !x_max || v.x2 > x_max ){
			x_max = v.x2;
		}
		if( !y_min || v.y1 < y_min ){
			y_min = v.y1;
		}
		if( !y_max || v.y2 > y_max ){
			y_max = v.y2;
		}
	}
	y_min -= 3*this.curveRadius;
	y_max += 3*this.curveRadius + 40;
	x_min -= 3*this.curveRadius;
	x_max += 3*this.curveRadius;
	if( this.config.options.lineBreaks && this.config.options.lineNumbering ){
		y_min -= 26;
	}
	var w = x_max - x_min;
	var h = y_max - y_min;
	if( this.config.options.lineBreaks ){
		w = $('#'+this.div).width();
	}
	this.paper = r;
	for( var i=0; i<this.layout.length; i++ ){
		var v = this.layout[i];
		v.y1 -= y_min;
		v.y2 -= y_min;
		if( !this.config.options.lineBreaks ){
			v.x1 -= x_min;
			v.x2 -= x_min;
		}			
	}
	for( var i=0; i<this.connections.length; i++ ){
		for( var j=0; j<this.connections[i].links.length; j++ ){
			this.connections[i].links[j].y1 -= y_min;
			this.connections[i].links[j].y2 -= y_min;
			if( !this.config.options.lineBreaks ){
				this.connections[i].links[j].x1 -= x_min;
				this.connections[i].links[j].x2 -= x_min;
			}			
		}			
	}
	r.setSize(w+"px",h+"px");
	for( var i=0; i<this.layers.length; i++ ){
		this.layers[i].yLevel -= y_min;
	}
	if( this.config.options.transpositions ){
		this.calculateTranspositions();
	}
	for( var i=0; i<this.layout.length; i++ ){
		var v = this.layout[i];
		if( v != this.startVertex && v != this.endVertex && v.token != '' && this.config.options.vertexBackground ){
			if (v.token == "CLOUD") {
				v.rect = r.rect(v.x1+3,v.y1-10,v.x2-v.x1-6,v.y2-v.y1+20,5).attr({fill: "red"});
			}
			else if( v.count > this.config.options.collapseLabels ){
				v.rect = r.rect(v.x1+3,v.y1,v.x2-v.x1-6,v.y2-v.y1,5).attr({fill: this.config.options.vertexBackground, "stroke": "none" });
			}
			else {
				v.rect = r.rect(v.x1+3,v.y1,v.x2-v.x1-6,v.y2-v.y1,5).attr({title: v.token, fill: this.config.options.vertexBackground, "stroke": "none" });
			}
		}
		if( v.count > this.config.options.collapseLabels ){
			var fs = this.config.options.fontSizeMin + this.config.options.fontSizeIncrease*(v.count-1);
			if( this.config.options.interpolateFontSize ){
				fs = this.config.options.fontSizeMin + (v.count-1)/(maxLabel-1) * (this.config.options.fontSizeMax - this.config.options.fontSizeMin);
			}
			v.fs = fs;
			if (v.token == "CLOUD") {
				v.textNode = r.text(( v.x1 + v.x2 )/2, ( v.y1 + v.y2 )/2, "").attr({font: fs+"px "+this.config.options.font,fill:this.config.options.baseColor,"text-anchor":"middle","cursor":"pointer"});
			}
			else {
				v.textNode = r.text(( v.x1 + v.x2 )/2, ( v.y1 + v.y2 )/2, v.token).attr({font: fs+"px "+this.config.options.font,fill:this.config.options.baseColor,"text-anchor":"middle","cursor":"pointer"});
			}
				
			setTooltip(v.textNode.node,v,r);
			$(v.textNode.node).css({
				"-webkit-touch-callout": "none",
				"-webkit-user-select": "none",
				"-khtml-user-select": "none",
				"-moz-user-select": "none",
				"-ms-user-select": "none",
				"user-select": "none",
			});
		}
	}
	this.edgeGroups = [];
	this.basicConnections = [];
	this.vertexConnections = [];
	if( this.config.options.connectionType == 'majority' ){
		this.majorityConnections(true);
	}
	else if( this.config.options.connectionType == 'all' ){
		this.majorityConnections(false);
	}
	else {
		this.generalConnections();
	}
	if( this.config.options.editionLabels ){
		this.computeEdgeLabels();
	}
	if( this.config.options.startAndEnd ){
		r.circle(this.startVertex.x1,this.startVertex.y1,4).attr({ fill: this.config.options.baseColor });
		r.rect(this.endVertex.x1,this.endVertex.y1-4,8,8).attr({ fill: this.config.options.baseColor });
	}
	if( this.config.options.lineBreaks && this.config.options.lineNumbering ){
		this.insertLineNumbering(w,gap);
	}
	$("<a class='TRAViz-copyright-link' target=_blank href='http://traviz.vizcovery.org'><div class='TRAViz-copyright'></div></a>").appendTo($('#'+this.div));
}
